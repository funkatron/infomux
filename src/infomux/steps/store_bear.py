"""
Store step: create note in Bear.app.

Creates a new note in Bear using the x-callback-url scheme.
Bear is a markdown note app for macOS and iOS.

This step uses Bear's URL scheme to create notes:
    bear://x-callback-url/create?title=...&text=...&tags=...

Environment variables:
    INFOMUX_BEAR_TAGS: Comma-separated default tags (default: "infomux,transcript")

Note: This only works on macOS with Bear installed.
Output: Opens Bear with the new note (no file output)
"""

from __future__ import annotations

import os
import subprocess
import time
import urllib.parse
from dataclasses import dataclass
from pathlib import Path

from infomux.log import get_logger
from infomux.steps import StepError, StepResult, register_step
from infomux.steps.storage import RunData, format_duration, format_timestamp

logger = get_logger(__name__)

# No local output
STORE_BEAR_FILENAME = None


def _get_bear_tags() -> list[str]:
    """Get Bear tags from environment."""
    tags_str = os.environ.get("INFOMUX_BEAR_TAGS", "infomux,transcript")
    return [t.strip() for t in tags_str.split(",") if t.strip()]


def _generate_bear_note(data: RunData) -> tuple[str, str]:
    """
    Generate Bear note content.

    Returns:
        Tuple of (title, body).
    """
    # Title
    if data.input_path:
        title = Path(data.input_path).stem
    else:
        title = f"Transcript {data.run_id}"

    lines = []

    # Metadata header
    lines.append(f"**Date:** {data.created_at[:10]}")
    if data.input_path:
        lines.append(f"**Source:** {Path(data.input_path).name}")
    if data.pipeline:
        lines.append(f"**Pipeline:** {data.pipeline}")
    if data.duration_seconds:
        lines.append(f"**Duration:** {format_duration(data.duration_seconds)}")
    lines.append(f"**Run ID:** `{data.run_id}`")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Summary
    if data.summary:
        lines.append("## Summary")
        lines.append("")
        lines.append(data.summary.strip())
        lines.append("")
        if data.summary_model:
            lines.append(f"*Summarized by {data.summary_model}*")
            lines.append("")
        lines.append("---")
        lines.append("")

    # Transcript
    if data.transcript_text:
        lines.append("## Transcript")
        lines.append("")
        lines.append(data.transcript_text.strip())
        lines.append("")

    # Timed segments (Bear supports folding with ::)
    if data.transcript_segments:
        lines.append("---")
        lines.append("")
        lines.append("## Timed Transcript")
        lines.append("")
        lines.append("::Timed segments::")
        lines.append("")
        for seg in data.transcript_segments:
            if seg.text:
                time_str = format_timestamp(seg.start_ms)
                lines.append(f"**{time_str}** {seg.text}")
                lines.append("")
        lines.append("::")
        lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*Generated by infomux*")

    return title, "\n".join(lines)


def _open_bear_url(title: str, text: str, tags: list[str]) -> None:
    """
    Open Bear with a new note using URL scheme.

    Args:
        title: Note title.
        text: Note body.
        tags: List of tags.
    """
    # Build Bear URL
    params = {
        "title": title,
        "text": text,
        "tags": ",".join(tags),
        "open_note": "yes",
    }

    url = "bear://x-callback-url/create?" + urllib.parse.urlencode(params)

    # Open URL on macOS
    try:
        subprocess.run(["open", url], check=True, capture_output=True)
    except subprocess.CalledProcessError as e:
        raise StepError("store_bear", f"Failed to open Bear: {e}")
    except FileNotFoundError:
        raise StepError(
            "store_bear",
            "macOS 'open' command not found. This step only works on macOS.",
        )


@register_step
@dataclass
class StoreBearStep:
    """
    Pipeline step to create note in Bear.app.

    Uses Bear's x-callback-url scheme to create a new note with:
    - Formatted metadata header
    - Summary (if available)
    - Full transcript
    - Collapsible timed segments

    Only works on macOS with Bear installed.
    """

    name: str = "store_bear"

    def execute(self, input_path: Path, output_dir: Path) -> list[Path]:
        """
        Create note in Bear.

        Args:
            input_path: Not used.
            output_dir: The run directory.

        Returns:
            Empty list (no file output, note created in Bear).

        Raises:
            StepError: If Bear creation fails.
        """
        import sys

        if sys.platform != "darwin":
            raise StepError(self.name, "Bear.app is only available on macOS")

        run_data = RunData.from_run_dir(output_dir)
        if not run_data:
            raise StepError(self.name, "No run data found")

        tags = _get_bear_tags()
        title, body = _generate_bear_note(run_data)

        logger.info("creating Bear note: %s", title)

        _open_bear_url(title, body, tags)

        logger.info("created note in Bear")
        return []


def run(input_path: Path, output_dir: Path) -> StepResult:
    """Run the store_bear step."""
    step = StoreBearStep()
    start_time = time.monotonic()

    try:
        outputs = step.execute(input_path, output_dir)
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=True,
            outputs=outputs,
            duration_seconds=duration,
        )
    except StepError as e:
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=False,
            outputs=[],
            duration_seconds=duration,
            error=str(e),
        )
