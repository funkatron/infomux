"""
Store step: create note in Bear.app.

Creates a new note in Bear using the x-callback-url scheme.
Bear is a markdown note app for macOS and iOS.

This step uses Bear's URL scheme to create notes:
    bear://x-callback-url/create?title=...&text=...&tags=...

Environment variables:
    INFOMUX_BEAR_TAGS: Comma-separated default tags (default: "infomux,transcript")

Note: This only works on macOS with Bear installed.
Output: Opens Bear with the new note (no file output)
"""

from __future__ import annotations

import os
import subprocess
import time
import urllib.parse
from dataclasses import dataclass
from pathlib import Path

from infomux.log import get_logger
from infomux.steps import StepError, StepResult, register_step
from infomux.steps.storage import RunData, format_duration, format_timestamp

logger = get_logger(__name__)

# No local output
STORE_BEAR_FILENAME = None


def _get_bear_tags() -> list[str]:
    """Get Bear tags from environment."""
    tags_str = os.environ.get("INFOMUX_BEAR_TAGS", "infomux,transcript")
    return [t.strip() for t in tags_str.split(",") if t.strip()]


def _get_base_title(data: RunData) -> str:
    """Get base title from input path or run ID."""
    if data.input_path:
        return Path(data.input_path).stem
    return f"Transcript {data.run_id}"


def _generate_main_note(data: RunData) -> tuple[str, str]:
    """
    Generate main Bear note with metadata, summary, and links.

    Returns:
        Tuple of (title, body).
    """
    base_title = _get_base_title(data)
    title = base_title

    lines = []

    # Metadata header
    lines.append(f"**Date:** {data.created_at[:10]}")
    if data.input_path:
        lines.append(f"**Source:** {Path(data.input_path).name}")
    if data.pipeline:
        lines.append(f"**Pipeline:** {data.pipeline}")
    if data.duration_seconds:
        lines.append(f"**Duration:** {format_duration(data.duration_seconds)}")
    lines.append(f"**Run ID:** `{data.run_id}`")
    lines.append("")

    # Links to related notes
    lines.append("## Contents")
    lines.append("")
    if data.transcript_text:
        lines.append(f"- [[{base_title} - Transcript]]")
    if data.transcript_segments:
        lines.append(f"- [[{base_title} - Timed]]")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Summary (included in main note since it's usually short)
    if data.summary:
        lines.append("## Summary")
        lines.append("")
        lines.append(data.summary.strip())
        lines.append("")
        if data.summary_model:
            lines.append(f"*Summarized by {data.summary_model}*")
            lines.append("")

    # Footer
    lines.append("---")
    lines.append("*Generated by infomux*")

    return title, "\n".join(lines)


def _generate_transcript_note(data: RunData) -> tuple[str, str] | None:
    """
    Generate transcript note.

    Returns:
        Tuple of (title, body) or None if no transcript.
    """
    if not data.transcript_text:
        return None

    base_title = _get_base_title(data)
    title = f"{base_title} - Transcript"

    lines = []
    lines.append(f"← [[{base_title}]]")
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append(data.transcript_text.strip())
    lines.append("")
    lines.append("---")
    lines.append("*Generated by infomux*")

    return title, "\n".join(lines)


def _generate_timed_note(data: RunData) -> tuple[str, str] | None:
    """
    Generate timed transcript note.

    Returns:
        Tuple of (title, body) or None if no segments.
    """
    if not data.transcript_segments:
        return None

    base_title = _get_base_title(data)
    title = f"{base_title} - Timed"

    lines = []
    lines.append(f"← [[{base_title}]]")
    lines.append("")
    lines.append("---")
    lines.append("")

    for seg in data.transcript_segments:
        if seg.text:
            time_str = format_timestamp(seg.start_ms)
            lines.append(f"**{time_str}** {seg.text}")
            lines.append("")

    lines.append("---")
    lines.append("*Generated by infomux*")

    return title, "\n".join(lines)


def _open_bear_url(
    title: str, text: str, tags: list[str], open_note: bool = False
) -> None:
    """
    Open Bear with a new note using URL scheme.

    Args:
        title: Note title.
        text: Note body.
        tags: List of tags.
        open_note: Whether to open the note after creation.
    """
    # Build Bear URL
    params = {
        "title": title,
        "text": text,
        "tags": ",".join(tags),
        "open_note": "yes" if open_note else "no",
    }

    url = "bear://x-callback-url/create?" + urllib.parse.urlencode(
        params, quote_via=urllib.parse.quote
    )

    # Open URL on macOS
    try:
        subprocess.run(["open", url], check=True, capture_output=True)
    except subprocess.CalledProcessError as e:
        raise StepError("store_bear", f"Failed to open Bear: {e}")
    except FileNotFoundError:
        raise StepError(
            "store_bear",
            "macOS 'open' command not found. This step only works on macOS.",
        )


@register_step
@dataclass
class StoreBearStep:
    """
    Pipeline step to create note in Bear.app.

    Uses Bear's x-callback-url scheme to create a new note with:
    - Formatted metadata header
    - Summary (if available)
    - Full transcript
    - Collapsible timed segments

    Only works on macOS with Bear installed.
    """

    name: str = "store_bear"

    def execute(self, input_path: Path, output_dir: Path) -> list[Path]:
        """
        Create notes in Bear.

        Creates separate linked notes:
        - Main note with metadata and summary
        - Transcript note (if transcript exists)
        - Timed transcript note (if timed segments exist)

        Args:
            input_path: Not used.
            output_dir: The run directory.

        Returns:
            Empty list (no file output, notes created in Bear).

        Raises:
            StepError: If Bear creation fails.
        """
        import sys
        import time as time_module

        if sys.platform != "darwin":
            raise StepError(self.name, "Bear.app is only available on macOS")

        run_data = RunData.from_run_dir(output_dir)
        if not run_data:
            raise StepError(self.name, "No run data found")

        tags = _get_bear_tags()
        notes_created = 0

        # Create timed transcript note first (so links work)
        timed_result = _generate_timed_note(run_data)
        if timed_result:
            title, body = timed_result
            logger.info("creating Bear note: %s", title)
            _open_bear_url(title, body, tags, open_note=False)
            notes_created += 1
            time_module.sleep(0.3)  # Small delay for Bear to process

        # Create transcript note
        transcript_result = _generate_transcript_note(run_data)
        if transcript_result:
            title, body = transcript_result
            logger.info("creating Bear note: %s", title)
            _open_bear_url(title, body, tags, open_note=False)
            notes_created += 1
            time_module.sleep(0.3)

        # Create main note last (and open it)
        title, body = _generate_main_note(run_data)
        logger.info("creating Bear note: %s", title)
        _open_bear_url(title, body, tags, open_note=True)
        notes_created += 1

        logger.info("created %d notes in Bear", notes_created)
        return []


def run(input_path: Path, output_dir: Path) -> StepResult:
    """Run the store_bear step."""
    step = StoreBearStep()
    start_time = time.monotonic()

    try:
        outputs = step.execute(input_path, output_dir)
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=True,
            outputs=outputs,
            duration_seconds=duration,
        )
    except StepError as e:
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=False,
            outputs=[],
            duration_seconds=duration,
            error=str(e),
        )
