"""
Store step: export to Obsidian vault.

Creates a markdown note in your Obsidian vault with:
- YAML frontmatter (tags, date, source, etc.)
- Wikilinks to related notes
- Properly formatted transcript and summary
- Callouts for key sections

Environment variables:
    INFOMUX_OBSIDIAN_VAULT: Path to Obsidian vault (required)
    INFOMUX_OBSIDIAN_FOLDER: Subfolder for transcripts (default: "Transcripts")
    INFOMUX_OBSIDIAN_TAGS: Comma-separated default tags (default: "infomux,transcript")

Output: Creates note in Obsidian vault
"""

from __future__ import annotations

import os
import re
import time
from dataclasses import dataclass
from pathlib import Path

from infomux.log import get_logger
from infomux.steps import StepError, StepResult, register_step
from infomux.steps.storage import RunData, format_duration, format_timestamp

logger = get_logger(__name__)

# No local output in run dir
STORE_OBSIDIAN_FILENAME = None


def _get_obsidian_config() -> tuple[Path, str, list[str]]:
    """
    Get Obsidian configuration from environment.

    Returns:
        Tuple of (vault_path, folder, tags).

    Raises:
        StepError: If vault not configured.
    """
    vault = os.environ.get("INFOMUX_OBSIDIAN_VAULT")
    if not vault:
        raise StepError(
            "store_obsidian",
            "INFOMUX_OBSIDIAN_VAULT not set. Set to your vault path.",
        )

    vault_path = Path(vault).expanduser()
    if not vault_path.exists():
        raise StepError("store_obsidian", f"Vault not found: {vault_path}")

    folder = os.environ.get("INFOMUX_OBSIDIAN_FOLDER", "Transcripts")
    tags_str = os.environ.get("INFOMUX_OBSIDIAN_TAGS", "infomux,transcript")
    tags = [t.strip() for t in tags_str.split(",") if t.strip()]

    return vault_path, folder, tags


def _sanitize_filename(name: str) -> str:
    """Sanitize string for use as filename."""
    # Remove or replace invalid characters
    name = re.sub(r'[<>:"/\\|?*]', "", name)
    name = name.strip(". ")
    return name[:100]  # Limit length


def _generate_obsidian_note(data: RunData, tags: list[str]) -> str:
    """Generate Obsidian-formatted markdown note."""
    lines = []

    # YAML frontmatter
    lines.append("---")
    lines.append(f"date: {data.created_at[:10]}")
    lines.append(f"created: {data.created_at[:19].replace('T', ' ')}")
    if data.input_path:
        lines.append(f"source: \"{Path(data.input_path).name}\"")
    if data.pipeline:
        lines.append(f"pipeline: {data.pipeline}")
    if data.duration_seconds:
        lines.append(f"duration: {format_duration(data.duration_seconds)}")
    lines.append(f"run_id: {data.run_id}")
    lines.append(f"tags: [{', '.join(tags)}]")
    lines.append("---")
    lines.append("")

    # Title
    if data.input_path:
        title = Path(data.input_path).stem
    else:
        title = data.run_id
    lines.append(f"# {title}")
    lines.append("")

    # Summary callout
    if data.summary:
        lines.append("> [!summary] Summary")
        for line in data.summary.strip().split("\n"):
            lines.append(f"> {line}")
        lines.append("")
        if data.summary_model:
            lines.append(f"*Summarized by {data.summary_model}*")
            lines.append("")

    # Transcript
    if data.transcript_text:
        lines.append("## Transcript")
        lines.append("")
        lines.append(data.transcript_text.strip())
        lines.append("")

    # Timed segments (collapsible)
    if data.transcript_segments:
        lines.append("## Timed Transcript")
        lines.append("")
        lines.append("> [!quote]- Click to expand timed segments")
        for seg in data.transcript_segments:
            if seg.text:
                time_str = format_timestamp(seg.start_ms)
                lines.append(f"> **{time_str}** {seg.text}")
        lines.append("")

    # Metadata
    lines.append("---")
    lines.append("")
    lines.append(f"*Generated by [[infomux]] on {data.created_at[:10]}*")

    return "\n".join(lines)


@register_step
@dataclass
class StoreObsidianStep:
    """
    Pipeline step to export to Obsidian vault.

    Creates a note with:
    - YAML frontmatter for metadata
    - Callouts for summary
    - Collapsible timed transcript
    - Wikilinks for cross-referencing

    Requires INFOMUX_OBSIDIAN_VAULT environment variable.
    """

    name: str = "store_obsidian"

    def execute(self, input_path: Path, output_dir: Path) -> list[Path]:
        """
        Export run to Obsidian vault.

        Args:
            input_path: Not used.
            output_dir: The run directory.

        Returns:
            List containing path to created note.

        Raises:
            StepError: If export fails.
        """
        vault_path, folder, tags = _get_obsidian_config()
        run_data = RunData.from_run_dir(output_dir)
        if not run_data:
            raise StepError(self.name, "No run data found")

        # Create folder if needed
        target_dir = vault_path / folder
        target_dir.mkdir(parents=True, exist_ok=True)

        # Generate filename from input or run_id
        if run_data.input_path:
            base_name = _sanitize_filename(Path(run_data.input_path).stem)
        else:
            base_name = run_data.run_id

        # Add date prefix for sorting
        date_prefix = run_data.created_at[:10]
        filename = f"{date_prefix} {base_name}.md"
        note_path = target_dir / filename

        logger.info("exporting to Obsidian: %s", note_path.relative_to(vault_path))

        try:
            note_content = _generate_obsidian_note(run_data, tags)

            with open(note_path, "w") as f:
                f.write(note_content)

            logger.info("created note: %s", filename)
            return [note_path]

        except OSError as e:
            raise StepError(self.name, f"export failed: {e}")


def run(input_path: Path, output_dir: Path) -> StepResult:
    """Run the store_obsidian step."""
    step = StoreObsidianStep()
    start_time = time.monotonic()

    try:
        outputs = step.execute(input_path, output_dir)
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=True,
            outputs=outputs,
            duration_seconds=duration,
        )
    except StepError as e:
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=False,
            outputs=[],
            duration_seconds=duration,
            error=str(e),
        )
