"""
Store step: generate formatted markdown report.

Creates a human-readable markdown report with all run data,
suitable for sharing, documentation, or printing.

Output: report.md in run directory
"""

from __future__ import annotations

import time
from dataclasses import dataclass
from pathlib import Path

from infomux.log import get_logger
from infomux.steps import StepError, StepResult, register_step
from infomux.steps.storage import RunData, format_duration, format_timestamp

logger = get_logger(__name__)

# Output filename
REPORT_MD_FILENAME = "report.md"


def _generate_report(data: RunData) -> str:
    """Generate markdown report from run data."""
    lines = []

    # Header
    lines.append("# Transcription Report")
    lines.append("")
    lines.append(f"**Run ID:** `{data.run_id}`")
    lines.append(f"**Date:** {data.created_at[:19].replace('T', ' ')}")
    if data.input_path:
        lines.append(f"**Input:** `{Path(data.input_path).name}`")
    if data.pipeline:
        lines.append(f"**Pipeline:** {data.pipeline}")
    if data.duration_seconds:
        lines.append(f"**Duration:** {format_duration(data.duration_seconds)}")
    lines.append("")

    # Summary (if available)
    if data.summary:
        lines.append("---")
        lines.append("")
        lines.append("## Summary")
        lines.append("")
        if data.summary_model:
            lines.append(f"*Generated by {data.summary_model}*")
            lines.append("")
        lines.append(data.summary)
        lines.append("")

    # Transcript
    if data.transcript_text:
        lines.append("---")
        lines.append("")
        lines.append("## Transcript")
        lines.append("")
        lines.append(data.transcript_text)
        lines.append("")

    # Timed segments (if available)
    if data.transcript_segments:
        lines.append("---")
        lines.append("")
        lines.append("## Timed Transcript")
        lines.append("")
        lines.append("| Time | Text |")
        lines.append("|------|------|")
        for seg in data.transcript_segments:
            if seg.text:  # Skip empty segments
                time_str = format_timestamp(seg.start_ms)
                # Escape pipes in text
                text = seg.text.replace("|", "\\|")
                lines.append(f"| {time_str} | {text} |")
        lines.append("")

    # Artifacts (if available)
    artifacts = data.job_json.get("artifacts", [])
    if artifacts:
        # Filter for video files
        video_files = [a for a in artifacts if Path(a).suffix.lower() in {".mp4", ".mov", ".avi", ".mkv"}]
        if video_files:
            lines.append("---")
            lines.append("")
            lines.append("## Generated Files")
            lines.append("")
            for artifact in video_files:
                artifact_name = Path(artifact).name
                lines.append(f"- `{artifact_name}` (video with subtitles)")
            lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*Generated by infomux*")

    return "\n".join(lines)


@register_step
@dataclass
class StoreMarkdownStep:
    """
    Pipeline step to generate a formatted markdown report.

    Creates a comprehensive, human-readable document with:
    - Run metadata
    - Summary (if available)
    - Full transcript
    - Timed segments as a table
    """

    name: str = "store_markdown"

    def execute(self, input_path: Path, output_dir: Path) -> list[Path]:
        """
        Generate markdown report.

        Args:
            input_path: Not used (reads from output_dir).
            output_dir: The run directory.

        Returns:
            List containing path to report.md.

        Raises:
            StepError: If generation fails.
        """
        run_data = RunData.from_run_dir(output_dir)
        if not run_data:
            raise StepError(self.name, "No run data found")

        output_path = output_dir / REPORT_MD_FILENAME

        logger.info("generating report: %s", output_path.name)

        try:
            report = _generate_report(run_data)

            with open(output_path, "w") as f:
                f.write(report)

            size = output_path.stat().st_size
            logger.info("generated: %s (%d bytes)", output_path.name, size)
            return [output_path]

        except OSError as e:
            raise StepError(self.name, f"generation failed: {e}")


def run(input_path: Path, output_dir: Path) -> StepResult:
    """Run the store_markdown step."""
    step = StoreMarkdownStep()
    start_time = time.monotonic()

    try:
        outputs = step.execute(input_path, output_dir)
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=True,
            outputs=outputs,
            duration_seconds=duration,
        )
    except StepError as e:
        duration = time.monotonic() - start_time
        return StepResult(
            name=step.name,
            success=False,
            outputs=[],
            duration_seconds=duration,
            error=str(e),
        )
